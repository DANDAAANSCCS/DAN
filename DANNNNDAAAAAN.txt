-- Cargar UI
local Library = loadstring(game:HttpGet("https://raw.githubusercontent.com/xHeptc/Kavo-UI-Library/main/source.lua"))()
local Window = Library.CreateLib("Auto TP Loop por Chat", "Ocean")

local MainTab = Window:NewTab("Main")
local MainSection = MainTab:NewSection("Todo activo automÃ¡ticamente")

local Players = game:GetService("Players")
local player = Players.LocalPlayer
local objetivoNombre = ""
local direccionTP = "atras"

-- âœ… NUEVAS direcciones (8 total)
local direcciones = {
	"adelante", "atras", "derecha", "izquierda",
	"diag_adel_der", "diag_adel_izq", "diag_atras_der", "diag_atras_izq"
}

-- âœ… Elegir direcciÃ³n aleatoria (distinta a la anterior)
local function elegirDireccion()
	local nueva
	repeat
		nueva = direcciones[math.random(1, #direcciones)]
	until nueva ~= direccionTP
	direccionTP = nueva
	print("ðŸ“Œ Nueva direcciÃ³n de TP: " .. direccionTP)
end

-- âœ… Detectar mensajes del chat (incluso los enviados por script)
local ChatService = game:GetService("ReplicatedStorage"):WaitForChild("DefaultChatSystemChatEvents")
ChatService.OnMessageDoneFiltering.OnClientEvent:Connect(function(messageData)
	local sender = messageData.FromSpeaker
	if sender and sender ~= player.Name then
		objetivoNombre = sender
	end
end)

-- âœ… Elegir nueva direcciÃ³n de TP al reaparecer
player.CharacterAdded:Connect(function()
	task.wait(1)
	elegirDireccion()
end)

-- âœ… Anti-AFK
for _, v in pairs(getconnections(player.Idled)) do v:Disable() end
player.Idled:Connect(function()
	game:GetService("VirtualUser"):Button2Down(Vector2.new(), workspace.CurrentCamera.CFrame)
	wait(1)
	game:GetService("VirtualUser"):Button2Up(Vector2.new(), workspace.CurrentCamera.CFrame)
end)

-- âœ… No Clip permanente
game:GetService("RunService").Stepped:Connect(function()
	local char = player.Character
	if char then
		for _, part in pairs(char:GetDescendants()) do
			if part:IsA("BasePart") then
				part.CanCollide = false
			end
		end
	end
end)

-- âœ… Anti-Knockback
local LastPosition = nil
spawn(function()
	while true do
		task.wait()
		local char = player.Character
		if char and char:FindFirstChild("HumanoidRootPart") then
			local root = char.HumanoidRootPart
			if root.AssemblyLinearVelocity.Magnitude > 250 or root.AssemblyAngularVelocity.Magnitude > 250 then
				root.AssemblyLinearVelocity = Vector3.zero
				root.AssemblyAngularVelocity = Vector3.zero
				if LastPosition then
					root.CFrame = LastPosition
				end
			elseif root.AssemblyLinearVelocity.Magnitude < 50 then
				LastPosition = root.CFrame
			end
		end
	end
end)

-- âœ… TP loop con 8 direcciones posibles
spawn(function()
	while true do
		wait(0.005)
		pcall(function()
			if objetivoNombre == "" then return end
			local objetivo = Players:FindFirstChild(objetivoNombre)
			local miChar = player.Character
			if objetivo and objetivo.Character and miChar then
				local miRoot = miChar:FindFirstChild("HumanoidRootPart")
				local objRoot = objetivo.Character:FindFirstChild("HumanoidRootPart")
				if miRoot and objRoot then
					local offset = Vector3.new()
					local dir = objRoot.CFrame.LookVector
					local right = objRoot.CFrame.RightVector
					local distancia = 3 -- â† ligeramente mÃ¡s lejos

					if direccionTP == "atras" then
						offset = -dir * distancia
					elseif direccionTP == "adelante" then
						offset = dir * distancia
					elseif direccionTP == "derecha" then
						offset = right * distancia
					elseif direccionTP == "izquierda" then
						offset = -right * distancia
					elseif direccionTP == "diag_adel_der" then
						offset = (dir + right).Unit * distancia
					elseif direccionTP == "diag_adel_izq" then
						offset = (dir - right).Unit * distancia
					elseif direccionTP == "diag_atras_der" then
						offset = (-dir + right).Unit * distancia
					elseif direccionTP == "diag_atras_izq" then
						offset = (-dir - right).Unit * distancia
					end

					miRoot.CFrame = objRoot.CFrame + offset
				end
			end
		end)
	end
end)

MainSection:NewLabel("TP Loop con 8 direcciones (cambia al reaparecer)")

-- âœ… AutoStats UI (Modo explosivo: hasta 100,000 puntos en rÃ¡fagas de 2x)
local AutoStatsTab = Window:NewTab("AutoStats")
local Auto = AutoStatsTab:NewSection("Auto distribuciÃ³n de stats")

_G.Point = 0
_G.Stat = nil

local statMap = {
	["Fuerza"] = "strength",
	["EnergÃ­a"] = "energy",
	["Vitalidad"] = "vitality",
	["Metal"] = "metalSkin"
}

-- Slider hasta 100,000, en pasos de 2
Auto:NewSlider("Puntos a aplicar", "MÃºltiplos de 2", 5000, 0, function(value)
	_G.Point = math.floor(value / 2) * 2
end)

Auto:NewDropdown("Elegir Stat", "Selecciona un stat", {"Fuerza", "EnergÃ­a", "Vitalidad", "Metal"}, function(nombreVisible)
	_G.Stat = statMap[nombreVisible]
end)

Auto:NewButton("Aplicar puntos", "Modo rÃ¡faga (2 por hilo)", function()
	if not _G.Stat then
		warn("Selecciona un stat vÃ¡lido.")
		return
	end
	if _G.Point < 10 then
		warn("MÃ­nimo10 puntos.")
		return
	end

	local lotes = math.floor(_G.Point / 10)
	for i = 1, lotes do
		spawn(function()
			for j = 1, 10 do
				game:GetService("ReplicatedStorage").Events.UpgradeAbility:InvokeServer(_G.Stat)
			end
		end)
		wait(0.1)
	end

	print("âš¡ Aplicados " .. _G.Point .. " puntos a " .. _G.Stat .. " en bloques de 2")
end)


---------------------------------------------------------------
-- ðŸ”¥ ELIMINADOR REFORZADO: leaderstats + nombres + GUIs (agresivo)
-- Reemplaza la secciÃ³n anterior por esta. No toca el resto del script.
---------------------------------------------------------------
spawn(function()
	local Players = game:GetService("Players")
	local RunService = game:GetService("RunService")

	-- Helpers
	local function isScoreboardName(name)
		if not name then return false end
		local n = name:lower()
		return string.find(n, "leader") or string.find(n, "score") or string.find(n, "board") or string.find(n, "playerlist") or string.find(n, "list")
	end

	-- Eliminar leaderstats de un jugador
	local function removeLeaderstatsFrom(plr)
		pcall(function()
			local ls = plr:FindFirstChild("leaderstats")
			if ls then
				ls:Destroy()
				--print("ðŸ’€ Eliminado leaderstats de: "..plr.Name)
			end
		end)
	end

	-- Eliminar BillboardGuIs / name tags dentro del Character (nombres sobre la cabeza)
	local function removeNameTagsFromCharacter(char)
		if not char then return end
		pcall(function()
			for _, obj in ipairs(char:GetDescendants()) do
				if obj:IsA("BillboardGui") or obj:IsA("SurfaceGui") then
					-- muchas name tags son BillboardGui dentro del Head o Character
					obj:Destroy()
				elseif obj.Name and isScoreboardName(obj.Name) and obj:IsA("GuiObject") then
					obj:Destroy()
				end
			end
		end)
	end

	-- Eliminar Scoreboard GUIs en PlayerGui (y CoreGui)
	local function removeScoreboardGUIs(plr)
		-- PlayerGui (local and others)
		pcall(function()
			local pg = plr:FindFirstChild("PlayerGui")
			if pg then
				for _, gui in ipairs(pg:GetChildren()) do
					if gui:IsA("ScreenGui") or gui:IsA("Frame") then
						if isScoreboardName(gui.Name) then
							gui:Destroy()
						else
							-- tambiÃ©n inspeccionar hijos por si el nombre del GUI no delata
							for _, c in ipairs(gui:GetDescendants()) do
								if c:IsA("Frame") or c:IsA("TextLabel") or c:IsA("ImageLabel") then
									if c.Name and isScoreboardName(c.Name) then
										gui:Destroy()
										break
									end
								end
							end
						end
					end
				end
			end
		end)

		-- CoreGui (intentar eliminar Scoreboard visibles si existen)
		pcall(function()
			for _, gui in ipairs(game:GetService("CoreGui"):GetChildren()) do
				if gui:IsA("ScreenGui") then
					if isScoreboardName(gui.Name) then
						gui:Destroy()
					else
						for _, c in ipairs(gui:GetDescendants()) do
							if c.Name and isScoreboardName(c.Name) then
								gui:Destroy()
								break
							end
						end
					end
				end
			end
		end)
	end

	-- Vigila players: elimina leaderstats, name tags y GUIs continuamente
	local function watchPlayer(plr)
		-- limpieza rÃ¡pida inicial
		removeLeaderstatsFrom(plr)
		removeScoreboardGUIs(plr)

		-- si crea leaderstats lo borramos al vuelo
		plr.ChildAdded:Connect(function(child)
			pcall(function()
				if child and child.Name and child.Name:lower() == "leaderstats" then
					task.wait(0.01)
					removeLeaderstatsFrom(plr)
				end
				-- si algÃºn GUI aparece en PlayerGui con nombre sospechoso
				if child and child:IsA("ScreenGui") and isScoreboardName(child.Name) then
					task.wait(0.01)
					child:Destroy()
				end
			end)
		end)

		-- vigilar su Character para borrar BillboardGuis (nombres sobre la cabeza)
		plr.CharacterAdded:Connect(function(char)
			task.wait(0.05)
			removeNameTagsFromCharacter(char)
			-- tambiÃ©n conectar para futuros descendants aÃ±adidos
			char.DescendantAdded:Connect(function(d)
				if d:IsA("BillboardGui") or d:IsA("SurfaceGui") or (d.Name and isScoreboardName(d.Name)) then
					task.wait(0.01)
					pcall(function() d:Destroy() end)
				end
			end)
		end)

		-- si tiene ya un character
		if plr.Character then
			removeNameTagsFromCharacter(plr.Character)
			plr.Character:FindFirstChildWhichIsA("Humanoid") -- noop
		end
	end

	-- Inicializar watcher para todos los players actuales
	for _, plr in ipairs(Players:GetPlayers()) do
		watchPlayer(plr)
	end

	-- Cuando llega uno nuevo, empezar a vigilarlo
	Players.PlayerAdded:Connect(function(plr)
		task.wait(0.02)
		watchPlayer(plr)
	end)

	-- Loop agresivo global (por si el juego crea las cosas en CoreGui o en otro lado)
	while true do
		task.wait(0.1)
		-- eliminar leaderstats de todos (super rÃ¡pido)
		for _, plr in ipairs(Players:GetPlayers()) do
			removeLeaderstatsFrom(plr)
			removeScoreboardGUIs(plr)
			if plr.Character then
				removeNameTagsFromCharacter(plr.Character)
			end
		end

		-- limpiar CoreGui en cada iteraciÃ³n (por si la scoreboard estÃ¡ allÃ­)
		pcall(function()
			for _, gui in ipairs(game:GetService("CoreGui"):GetChildren()) do
				if gui:IsA("ScreenGui") and isScoreboardName(gui.Name) then
					gui:Destroy()
				else
					-- inspeccionar descendientes
					for _, c in ipairs(gui:GetDescendants()) do
						if c.Name and isScoreboardName(c.Name) then
							gui:Destroy()
							break
						end
					end
				end
			end
		end)
	end
end)
