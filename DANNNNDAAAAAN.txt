-- Cargar UI
local Library = loadstring(game:HttpGet("https://raw.githubusercontent.com/xHeptc/Kavo-UI-Library/main/source.lua"))()
local Window = Library.CreateLib("Auto TP Loop - Coordenadas Fijas", "Ocean")

local MainTab = Window:NewTab("Main")
local MainSection = MainTab:NewSection("TP a Coordenadas Fijas")

local Players = game:GetService("Players")
local player = Players.LocalPlayer
local direccionTP = "atras"

-- âœ… Coordenadas objetivo fijas
local COORDENADAS_OBJETIVO = Vector3.new(650, 779, 284)
local DISTANCIA_OFFSET = 3 -- Distancia del offset alrededor del punto

-- âœ… 8 direcciones disponibles
local direcciones = {
	"adelante", "atras", "derecha", "izquierda",
	"diag_adel_der", "diag_adel_izq", "diag_atras_der", "diag_atras_izq"
}

-- âœ… Elegir direcciÃ³n aleatoria (distinta a la anterior)
local function elegirDireccion()
	local nueva
	repeat
		nueva = direcciones[math.random(1, #direcciones)]
	until nueva ~= direccionTP
	direccionTP = nueva
	print("ðŸ“Œ Nueva direcciÃ³n de TP: " .. direccionTP)
end

-- âœ… Calcular offset segÃºn direcciÃ³n (basado en ejes del mundo)
local function calcularOffset()
	local offset = Vector3.new()
	
	-- Usamos los ejes del mundo como referencia
	local adelante = Vector3.new(0, 0, -1) -- -Z es "adelante" en Roblox
	local derecha = Vector3.new(1, 0, 0)   -- +X es "derecha"
	
	if direccionTP == "atras" then
		offset = -adelante * DISTANCIA_OFFSET
	elseif direccionTP == "adelante" then
		offset = adelante * DISTANCIA_OFFSET
	elseif direccionTP == "derecha" then
		offset = derecha * DISTANCIA_OFFSET
	elseif direccionTP == "izquierda" then
		offset = -derecha * DISTANCIA_OFFSET
	elseif direccionTP == "diag_adel_der" then
		offset = (adelante + derecha).Unit * DISTANCIA_OFFSET
	elseif direccionTP == "diag_adel_izq" then
		offset = (adelante - derecha).Unit * DISTANCIA_OFFSET
	elseif direccionTP == "diag_atras_der" then
		offset = (-adelante + derecha).Unit * DISTANCIA_OFFSET
	elseif direccionTP == "diag_atras_izq" then
		offset = (-adelante - derecha).Unit * DISTANCIA_OFFSET
	end
	
	return offset
end

-- âœ… Elegir nueva direcciÃ³n de TP al reaparecer
player.CharacterAdded:Connect(function()
	task.wait(1)
	elegirDireccion()
end)

-- âœ… Anti-AFK
for _, v in pairs(getconnections(player.Idled)) do v:Disable() end
player.Idled:Connect(function()
	game:GetService("VirtualUser"):Button2Down(Vector2.new(), workspace.CurrentCamera.CFrame)
	wait(1)
	game:GetService("VirtualUser"):Button2Up(Vector2.new(), workspace.CurrentCamera.CFrame)
end)

-- âœ… No Clip permanente
game:GetService("RunService").Stepped:Connect(function()
	local char = player.Character
	if char then
		for _, part in pairs(char:GetDescendants()) do
			if part:IsA("BasePart") then
				part.CanCollide = false
			end
		end
	end
end)

-- âœ… Anti-Knockback
local LastPosition = nil
spawn(function()
	while true do
		task.wait()
		local char = player.Character
		if char and char:FindFirstChild("HumanoidRootPart") then
			local root = char.HumanoidRootPart
			if root.AssemblyLinearVelocity.Magnitude > 250 or root.AssemblyAngularVelocity.Magnitude > 250 then
				root.AssemblyLinearVelocity = Vector3.zero
				root.AssemblyAngularVelocity = Vector3.zero
				if LastPosition then
					root.CFrame = LastPosition
				end
			elseif root.AssemblyLinearVelocity.Magnitude < 50 then
				LastPosition = root.CFrame
			end
		end
	end
end)

-- âœ… TP loop a coordenadas fijas con 8 direcciones posibles
spawn(function()
	while true do
		wait(0.005)
		pcall(function()
			local miChar = player.Character
			if miChar then
				local miRoot = miChar:FindFirstChild("HumanoidRootPart")
				if miRoot then
					local offset = calcularOffset()
					local posicionFinal = COORDENADAS_OBJETIVO + offset
					miRoot.CFrame = CFrame.new(posicionFinal)
				end
			end
		end)
	end
end)

MainSection:NewLabel("ðŸ“ Coordenadas: 650, 779, 284")
MainSection:NewLabel("ðŸ”„ TP con 8 direcciones (cambia al reaparecer)")
MainSection:NewLabel("ðŸš« No Clip + Anti-Knockback activos")

-- âœ… PestaÃ±a de configuraciÃ³n
local ConfigTab = Window:NewTab("ConfiguraciÃ³n")
local ConfigSection = ConfigTab:NewSection("Ajustes del TP")

ConfigSection:NewButton("Cambiar direcciÃ³n ahora", "Fuerza un cambio de direcciÃ³n", function()
	elegirDireccion()
end)

ConfigSection:NewSlider("Distancia del offset", "QuÃ© tan lejos del centro", 10, 1, function(value)
	DISTANCIA_OFFSET = value
	print("ðŸ“ Nueva distancia de offset: " .. value)
end)

ConfigSection:NewButton("Ver estado actual", "Muestra info del TP", function()
	print("â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•")
	print("ðŸ“ Coordenadas objetivo: " .. tostring(COORDENADAS_OBJETIVO))
	print("ðŸ“Œ DirecciÃ³n actual: " .. direccionTP)
	print("ðŸ“ Distancia offset: " .. DISTANCIA_OFFSET)
	print("â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•")
end)

-- âœ… AutoStats UI (conservado del original)
local AutoStatsTab = Window:NewTab("AutoStats")
local Auto = AutoStatsTab:NewSection("Auto distribuciÃ³n de stats")

_G.Point = 0
_G.Stat = nil

local statMap = {
	["Fuerza"] = "strength",
	["EnergÃ­a"] = "energy",
	["Vitalidad"] = "vitality",
	["Metal"] = "metalSkin"
}

Auto:NewSlider("Puntos a aplicar", "MÃºltiplos de 2", 5000, 0, function(value)
	_G.Point = math.floor(value / 2) * 2
end)

Auto:NewDropdown("Elegir Stat", "Selecciona un stat", {"Fuerza", "EnergÃ­a", "Vitalidad", "Metal"}, function(nombreVisible)
	_G.Stat = statMap[nombreVisible]
end)

Auto:NewButton("Aplicar puntos", "Modo rÃ¡faga (2 por hilo)", function()
	if not _G.Stat then
		warn("Selecciona un stat vÃ¡lido.")
		return
	end
	if _G.Point < 10 then
		warn("MÃ­nimo 10 puntos.")
		return
	end

	local lotes = math.floor(_G.Point / 10)
	for i = 1, lotes do
		spawn(function()
			for j = 1, 10 do
				game:GetService("ReplicatedStorage").Events.UpgradeAbility:InvokeServer(_G.Stat)
			end
		end)
		wait(0.1)
	end

	print("âš¡ Aplicados " .. _G.Point .. " puntos a " .. _G.Stat .. " en bloques de 2")
end)

---------------------------------------------------------------
-- ðŸ”¥ ELIMINADOR DE UI (nombres, leaderboards, etc.)
---------------------------------------------------------------
spawn(function()
	local Players = game:GetService("Players")
	local CoreGui = game:GetService("CoreGui")

	local function isScoreboardName(name)
		if not name then return false end
		local n = name:lower()
		return string.find(n, "leader") or string.find(n, "score") or string.find(n, "board") or string.find(n, "playerlist") or string.find(n, "list")
	end

	local function isKavoUI(gui)
		if not gui or not gui.Name then return false end
		local name = gui.Name:lower()
		if string.find(name, "kavo") or string.find(name, "auto tp loop") or string.find(name, "coordenadas") then
			return true
		end
		for _, d in ipairs(gui:GetDescendants()) do
			if d.Name == "TopFrame" or d.Name == "MainFrame" or d.Name == "TabContainer" then
				return true
			end
		end
		return false
	end

	local function removeLeaderstats(plr)
		if plr == player then
			pcall(function()
				local ls = plr:FindFirstChild("leaderstats")
				if ls then ls:Destroy() end
			end)
		end
	end

	local function removeNameTags(char)
		if not char then return end
		pcall(function()
			for _, obj in ipairs(char:GetDescendants()) do
				if obj:IsA("BillboardGui") or obj:IsA("SurfaceGui") then
					obj:Destroy()
				elseif obj.Name and isScoreboardName(obj.Name) then
					obj:Destroy()
				end
			end
		end)
	end

	local function removeBadGUIs(container)
		pcall(function()
			for _, gui in ipairs(container:GetChildren()) do
				if gui:IsA("ScreenGui") then
					if not isKavoUI(gui) and isScoreboardName(gui.Name) then
						gui:Destroy()
					end
				end
			end
		end)
	end

	local function watch(plr)
		if plr == player then
			removeLeaderstats(plr)
		end
		if plr.Character then removeNameTags(plr.Character) end

		plr.ChildAdded:Connect(function(c)
			task.wait(0.05)
			if plr == player and c.Name:lower() == "leaderstats" then
				removeLeaderstats(plr)
			end
		end)

		plr.CharacterAdded:Connect(function(char)
			task.wait(0.1)
			removeNameTags(char)
			char.DescendantAdded:Connect(function(d)
				task.wait(0.05)
				if d:IsA("BillboardGui") or d:IsA("SurfaceGui") or (d.Name and isScoreboardName(d.Name)) then
					pcall(function() d:Destroy() end)
				end
			end)
		end)
	end

	for _, plr in ipairs(Players:GetPlayers()) do
		watch(plr)
	end

	Players.PlayerAdded:Connect(function(plr)
		task.wait(0.1)
		watch(plr)
	end)

	while true do
		task.wait(0.3)
		for _, plr in ipairs(Players:GetPlayers()) do
			if plr == player then
				removeLeaderstats(plr)
			end
			if plr.Character then removeNameTags(plr.Character) end
		end
		removeBadGUIs(CoreGui)
	end
end)

print("â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•")
print("âœ… Script cargado correctamente")
print("ðŸ“ TP Loop a coordenadas: 650, 779, 284")
print("ðŸ”„ DirecciÃ³n inicial: " .. direccionTP)
print("ðŸ“ Distancia offset: " .. DISTANCIA_OFFSET)
print("â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•")
		_rbg(_CG)
	end
end)
